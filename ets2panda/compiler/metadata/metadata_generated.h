/**
 * Copyright (c) 2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_METADATA_METADATA_H_
#define FLATBUFFERS_GENERATED_METADATA_METADATA_H_

#include "flatbuffers/flatbuffers.h"

namespace Metadata {

struct Root;
struct RootBuilder;

struct ClassDecl;
struct ClassDeclBuilder;

struct InterfaceDecl;
struct InterfaceDeclBuilder;

struct EnumDecl;
struct EnumDeclBuilder;

struct AnnotationDecl;
struct AnnotationDeclBuilder;

struct TypeDecl;
struct TypeDeclBuilder;

struct FunctionDecl;
struct FunctionDeclBuilder;

struct VarDecl;
struct VarDeclBuilder;

struct PropertyDecl;
struct PropertyDeclBuilder;

struct ValueParamDecl;
struct ValueParamDeclBuilder;

struct TypeParamDecl;
struct TypeParamDeclBuilder;

struct BuiltinType;
struct BuiltinTypeBuilder;

struct InternalTypeRef;
struct InternalTypeRefBuilder;

struct ExternalTypeRef;
struct ExternalTypeRefBuilder;

struct FunctionTypeParam;
struct FunctionTypeParamBuilder;

struct FunctionType;
struct FunctionTypeBuilder;

struct TupleType;
struct TupleTypeBuilder;

struct UnionType;
struct UnionTypeBuilder;

struct StringLiteralType;
struct StringLiteralTypeBuilder;

enum RefType : uint8_t {
    REF_TYPE_NONE = 0,
    REF_TYPE_CLASS = 1,
    REF_TYPE_INTERFACE = 2,
    REF_TYPE_ENUM = 3,
    REF_TYPE_ANNOTATION = 4,
    REF_TYPE_TYPE = 5,
    REF_TYPE_TYPE_PARAM = 6,
    REF_TYPE_MIN = REF_TYPE_NONE,
    REF_TYPE_MAX = REF_TYPE_TYPE_PARAM
};

inline const RefType (&EnumValuesRefType())[7]
{
    static const RefType values[] = {REF_TYPE_NONE,       REF_TYPE_CLASS, REF_TYPE_INTERFACE, REF_TYPE_ENUM,
                                     REF_TYPE_ANNOTATION, REF_TYPE_TYPE,  REF_TYPE_TYPE_PARAM};
    return values;
}

inline const char *const *EnumNamesRefType()
{
    static const char *const names[8] = {"NONE",       "class_", "interface", "enum_",
                                         "annotation", "type",   "typeParam", nullptr};
    return names;
}

inline const char *EnumNameRefType(RefType e)
{
    if (::flatbuffers::IsOutRange(e, REF_TYPE_NONE, REF_TYPE_TYPE_PARAM)) {
        return "";
    }
    const size_t index = static_cast<size_t>(e);
    return EnumNamesRefType()[index];
}

template <typename T>
struct RefTypeTraits {
    static const RefType enumValue = REF_TYPE_NONE;
};

template <>
struct RefTypeTraits<Metadata::ClassDecl> {
    static const RefType enumValue = REF_TYPE_CLASS;
};

template <>
struct RefTypeTraits<Metadata::InterfaceDecl> {
    static const RefType enumValue = REF_TYPE_INTERFACE;
};

template <>
struct RefTypeTraits<Metadata::EnumDecl> {
    static const RefType enumValue = REF_TYPE_ENUM;
};

template <>
struct RefTypeTraits<Metadata::AnnotationDecl> {
    static const RefType enumValue = REF_TYPE_ANNOTATION;
};

template <>
struct RefTypeTraits<Metadata::TypeDecl> {
    static const RefType enumValue = REF_TYPE_TYPE;
};

template <>
struct RefTypeTraits<Metadata::TypeParamDecl> {
    static const RefType enumValue = REF_TYPE_TYPE_PARAM;
};

bool VerifyRefType(::flatbuffers::Verifier &verifier, const void *obj, RefType type);
bool VerifyRefTypeVector(::flatbuffers::Verifier &verifier,
                         const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                         const ::flatbuffers::Vector<uint8_t> *types);

enum Type : uint8_t {
    TYPE_NONE = 0,
    TYPE_BUILTIN = 1,
    TYPE_REF_INTERNAL = 2,
    TYPE_REF_EXTERNAL = 3,
    TYPE_FUNCTION = 4,
    TYPE_FUPLE = 5,
    TYPE_UNION = 6,
    TYPE_STRING_LITERAL = 7,
    TYPE_MIN = TYPE_NONE,
    TYPE_MAX = TYPE_STRING_LITERAL
};

inline const Type (&EnumValuesType())[8]
{
    static const Type values[] = {TYPE_NONE,     TYPE_BUILTIN, TYPE_REF_INTERNAL, TYPE_REF_EXTERNAL,
                                  TYPE_FUNCTION, TYPE_FUPLE,   TYPE_UNION,        TYPE_STRING_LITERAL};
    return values;
}

inline const char *const *EnumNamesType()
{
    static const char *const names[9] = {"NONE",  "Builtin", "RefInternal",   "RefExternal", "Function",
                                         "Tuple", "Union",   "StringLiteral", nullptr};
    return names;
}

inline const char *EnumNameType(Type e)
{
    if (::flatbuffers::IsOutRange(e, TYPE_NONE, TYPE_STRING_LITERAL)) {
        return "";
    }
    const size_t index = static_cast<size_t>(e);
    return EnumNamesType()[index];
}

template <typename T>
struct TypeTraits {
    static const Type enumValue = TYPE_NONE;
};

template <>
struct TypeTraits<Metadata::BuiltinType> {
    static const Type enumValue = TYPE_BUILTIN;
};

template <>
struct TypeTraits<Metadata::InternalTypeRef> {
    static const Type enumValue = TYPE_REF_INTERNAL;
};

template <>
struct TypeTraits<Metadata::ExternalTypeRef> {
    static const Type enumValue = TYPE_REF_EXTERNAL;
};

template <>
struct TypeTraits<Metadata::FunctionType> {
    static const Type enumValue = TYPE_FUNCTION;
};

template <>
struct TypeTraits<Metadata::TupleType> {
    static const Type enumValue = TYPE_FUPLE;
};

template <>
struct TypeTraits<Metadata::UnionType> {
    static const Type enumValue = TYPE_UNION;
};

template <>
struct TypeTraits<Metadata::StringLiteralType> {
    static const Type enumValue = TYPE_STRING_LITERAL;
};

bool VerifyType(::flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(::flatbuffers::Verifier &verifier,
                      const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                      const ::flatbuffers::Vector<uint8_t> *types);

enum TypeParamVariance : int8_t {
    TYPE_PARAM_VARIANCE_INV = 0,
    TYPE_PARAM_VARIANCE_IN = 1,
    TYPE_PARAM_VARIANCE_OUT = 2,
    TYPE_PARAM_VARIANCE_MIN = TYPE_PARAM_VARIANCE_INV,
    TYPE_PARAM_VARIANCE_MAX = TYPE_PARAM_VARIANCE_OUT
};

inline const TypeParamVariance (&EnumValuesTypeParamVariance())[3]
{
    static const TypeParamVariance values[] = {TYPE_PARAM_VARIANCE_INV, TYPE_PARAM_VARIANCE_IN,
                                               TYPE_PARAM_VARIANCE_OUT};
    return values;
}

inline const char *const *EnumNamesTypeParamVariance()
{
    static const char *const names[4] = {"INV", "IN", "OUT", nullptr};
    return names;
}

inline const char *EnumNameTypeParamVariance(TypeParamVariance e)
{
    if (::flatbuffers::IsOutRange(e, TYPE_PARAM_VARIANCE_INV, TYPE_PARAM_VARIANCE_OUT)) {
        return "";
    }
    const size_t index = static_cast<size_t>(e);
    return EnumNamesTypeParamVariance()[index];
}

enum BuiltinTypeKind : int8_t {
    BUILTIN_TYPE_KIND_BYTE = 0,
    BUILTIN_TYPE_KIND_SHORT = 1,
    BUILTIN_TYPE_KIND_INT = 2,
    BUILTIN_TYPE_KIND_LONG = 3,
    BUILTIN_TYPE_KIND_FLOAT = 4,
    BUILTIN_TYPE_KIND_DOUBLE = 5,
    BUILTIN_TYPE_KIND_NUMBER = 6,
    BUILTIN_TYPE_KIND_BOOLEAN = 7,
    BUILTIN_TYPE_KIND_CHAR = 8,
    BUILTIN_TYPE_KIND_STRING = 9,
    BUILTIN_TYPE_KIND_BIGINT = 10,
    BUILTIN_TYPE_KIND_ANY = 11,
    BUILTIN_TYPE_KIND_OBJECT = 12,
    BUILTIN_TYPE_KIND_NEVER = 13,
    BUILTIN_TYPE_KIND_VOID = 14,
    BUILTIN_TYPE_KIND_UNDEFINED = 15,
    BUILTIN_TYPE_KIND_NULL = 16,
    BUILTIN_TYPE_KIND_ARRAY = 17,
    BUILTIN_TYPE_KIND_MIN = BUILTIN_TYPE_KIND_BYTE,
    BUILTIN_TYPE_KIND_MAX = BUILTIN_TYPE_KIND_ARRAY
};

inline const BuiltinTypeKind (&EnumValuesBuiltinTypeKind())[18]
{
    static const BuiltinTypeKind values[] = {
        BUILTIN_TYPE_KIND_BYTE,   BUILTIN_TYPE_KIND_SHORT,  BUILTIN_TYPE_KIND_INT,    BUILTIN_TYPE_KIND_LONG,
        BUILTIN_TYPE_KIND_FLOAT,  BUILTIN_TYPE_KIND_DOUBLE, BUILTIN_TYPE_KIND_NUMBER, BUILTIN_TYPE_KIND_BOOLEAN,
        BUILTIN_TYPE_KIND_CHAR,   BUILTIN_TYPE_KIND_STRING, BUILTIN_TYPE_KIND_BIGINT, BUILTIN_TYPE_KIND_ANY,
        BUILTIN_TYPE_KIND_OBJECT, BUILTIN_TYPE_KIND_NEVER,  BUILTIN_TYPE_KIND_VOID,   BUILTIN_TYPE_KIND_UNDEFINED,
        BUILTIN_TYPE_KIND_NULL,   BUILTIN_TYPE_KIND_ARRAY};
    return values;
}

inline const char *const *EnumNamesBuiltinTypeKind()
{
    static const char *const names[19] = {"byte",    "short_",    "int_",   "long_",  "float_", "double_", "number",
                                          "boolean", "char_",     "string", "bigint", "any",    "object",  "never",
                                          "void_",   "undefined", "null",   "array",  nullptr};
    return names;
}

inline const char *EnumNameBuiltinTypeKind(BuiltinTypeKind e)
{
    if (::flatbuffers::IsOutRange(e, BUILTIN_TYPE_KIND_BYTE, BUILTIN_TYPE_KIND_ARRAY)) {
        return "";
    }
    const size_t index = static_cast<size_t>(e);
    return EnumNamesBuiltinTypeKind()[index];
}

struct Root FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef RootBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_CLASSES = 4,
        VT_INTERFACES = 6,
        VT_ENUMS = 8,
        VT_ANNOTATIONS = 10,
        VT_TYPES = 12,
        VT_FUNCTIONS = 14,
        VT_PROPERTIES = 16,
        VT_VARIABLES = 18
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ClassDecl>> *classes() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ClassDecl>> *>(VT_CLASSES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ClassDecl>> *mutable_classes()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ClassDecl>> *>(VT_CLASSES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::InterfaceDecl>> *interfaces() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::InterfaceDecl>> *>(VT_INTERFACES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::InterfaceDecl>> *mutable_interfaces()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::InterfaceDecl>> *>(VT_INTERFACES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::EnumDecl>> *enums() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::EnumDecl>> *>(VT_ENUMS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::EnumDecl>> *mutable_enums()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::EnumDecl>> *>(VT_ENUMS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::AnnotationDecl>> *annotations() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::AnnotationDecl>> *>(
            VT_ANNOTATIONS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::AnnotationDecl>> *mutable_annotations()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::AnnotationDecl>> *>(VT_ANNOTATIONS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeDecl>> *types() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeDecl>> *>(VT_TYPES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeDecl>> *mutable_types()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeDecl>> *>(VT_TYPES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *functions() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_FUNCTIONS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *mutable_functions()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_FUNCTIONS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *properties() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *>(VT_PROPERTIES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *mutable_properties()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *>(VT_PROPERTIES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *variables() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *>(VT_VARIABLES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *mutable_variables()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *>(VT_VARIABLES);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CLASSES) && verifier.VerifyVector(classes()) &&
               verifier.VerifyVectorOfTables(classes()) && VerifyOffset(verifier, VT_INTERFACES) &&
               verifier.VerifyVector(interfaces()) && verifier.VerifyVectorOfTables(interfaces()) &&
               VerifyOffset(verifier, VT_ENUMS) && verifier.VerifyVector(enums()) &&
               verifier.VerifyVectorOfTables(enums()) && VerifyOffset(verifier, VT_ANNOTATIONS) &&
               verifier.VerifyVector(annotations()) && verifier.VerifyVectorOfTables(annotations()) &&
               VerifyOffset(verifier, VT_TYPES) && verifier.VerifyVector(types()) &&
               verifier.VerifyVectorOfTables(types()) && VerifyOffset(verifier, VT_FUNCTIONS) &&
               verifier.VerifyVector(functions()) && verifier.VerifyVectorOfTables(functions()) &&
               VerifyOffset(verifier, VT_PROPERTIES) && verifier.VerifyVector(properties()) &&
               verifier.VerifyVectorOfTables(properties()) && VerifyOffset(verifier, VT_VARIABLES) &&
               verifier.VerifyVector(variables()) && verifier.VerifyVectorOfTables(variables()) && verifier.EndTable();
    }
};

struct RootBuilder {
    typedef Root Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_classes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ClassDecl>>> classes)
    {
        fbb_.AddOffset(Root::VT_CLASSES, classes);
    }
    void add_interfaces(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::InterfaceDecl>>> interfaces)
    {
        fbb_.AddOffset(Root::VT_INTERFACES, interfaces);
    }
    void add_enums(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::EnumDecl>>> enums)
    {
        fbb_.AddOffset(Root::VT_ENUMS, enums);
    }
    void add_annotations(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::AnnotationDecl>>> annotations)
    {
        fbb_.AddOffset(Root::VT_ANNOTATIONS, annotations);
    }
    void add_types(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeDecl>>> types)
    {
        fbb_.AddOffset(Root::VT_TYPES, types);
    }
    void add_functions(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> functions)
    {
        fbb_.AddOffset(Root::VT_FUNCTIONS, functions);
    }
    void add_properties(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>>> properties)
    {
        fbb_.AddOffset(Root::VT_PROPERTIES, properties);
    }
    void add_variables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>>> variables)
    {
        fbb_.AddOffset(Root::VT_VARIABLES, variables);
    }
    explicit RootBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Root> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Root>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Root> CreateRoot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ClassDecl>>> classes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::InterfaceDecl>>> interfaces = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::EnumDecl>>> enums = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::AnnotationDecl>>> annotations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeDecl>>> types = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> functions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>>> properties = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>>> variables = 0)
{
    RootBuilder builder(_fbb);
    builder.add_variables(variables);
    builder.add_properties(properties);
    builder.add_functions(functions);
    builder.add_types(types);
    builder.add_annotations(annotations);
    builder.add_enums(enums);
    builder.add_interfaces(interfaces);
    builder.add_classes(classes);
    return builder.Finish();
}

inline ::flatbuffers::Offset<Root> CreateRootDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Metadata::ClassDecl>> *classes = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::InterfaceDecl>> *interfaces = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::EnumDecl>> *enums = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::AnnotationDecl>> *annos = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::TypeDecl>> *types = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *functions = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *properties = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::VarDecl>> *variables = nullptr)
{
    auto classes__ = classes ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::ClassDecl>>(*classes) : 0;
    auto interfaces__ = interfaces ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::InterfaceDecl>>(*interfaces) : 0;
    auto enums__ = enums ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::EnumDecl>>(*enums) : 0;
    auto annotations__ = annos ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::AnnotationDecl>>(*annos) : 0;
    auto types__ = types ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::TypeDecl>>(*types) : 0;
    auto functions__ = functions ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::FunctionDecl>>(*functions) : 0;
    auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::PropertyDecl>>(*properties) : 0;
    auto variables__ = variables ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::VarDecl>>(*variables) : 0;
    return Metadata::CreateRoot(_fbb, classes__, interfaces__, enums__, annotations__, types__, functions__,
                                properties__, variables__);
}

struct ClassDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ClassDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NAME = 4,
        VT_METHODS = 6,
        VT_FIELDS = 8,
        VT_PROPERTIES = 10,
        VT_TYPE_PARAMS = 12,
        VT_EXTENDED_CLASS_TYPE = 14,
        VT_EXTENDED_CLASS = 16,
        VT_IMPLEMENTED_INTERFACES_TYPE = 18,
        VT_IMPLEMENTED_INTERFACES = 20
    };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *methods() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_METHODS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *mutable_methods()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_METHODS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *fields() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *>(VT_FIELDS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *mutable_fields()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>> *>(VT_FIELDS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *properties() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *>(VT_PROPERTIES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *mutable_properties()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *>(VT_PROPERTIES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *type_params() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *>(
            VT_TYPE_PARAMS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *mutable_type_params()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *>(VT_TYPE_PARAMS);
    }
    Metadata::Type extended_class_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_EXTENDED_CLASS_TYPE, 0));
    }
    const void *extended_class() const
    {
        return GetPointer<const void *>(VT_EXTENDED_CLASS);
    }
    template <typename T>
    const T *extended_class_as() const;
    const Metadata::BuiltinType *extended_class_as_Builtin() const
    {
        return extended_class_type() == Metadata::TYPE_BUILTIN
                   ? static_cast<const Metadata::BuiltinType *>(extended_class())
                   : nullptr;
    }
    const Metadata::InternalTypeRef *extended_class_as_RefInternal() const
    {
        return extended_class_type() == Metadata::TYPE_REF_INTERNAL
                   ? static_cast<const Metadata::InternalTypeRef *>(extended_class())
                   : nullptr;
    }
    const Metadata::ExternalTypeRef *extended_class_as_RefExternal() const
    {
        return extended_class_type() == Metadata::TYPE_REF_EXTERNAL
                   ? static_cast<const Metadata::ExternalTypeRef *>(extended_class())
                   : nullptr;
    }
    const Metadata::FunctionType *extended_class_as_Function() const
    {
        return extended_class_type() == Metadata::TYPE_FUNCTION
                   ? static_cast<const Metadata::FunctionType *>(extended_class())
                   : nullptr;
    }
    const Metadata::TupleType *extended_class_as_Tuple() const
    {
        return extended_class_type() == Metadata::TYPE_FUPLE
                   ? static_cast<const Metadata::TupleType *>(extended_class())
                   : nullptr;
    }
    const Metadata::UnionType *extended_class_as_Union() const
    {
        return extended_class_type() == Metadata::TYPE_UNION
                   ? static_cast<const Metadata::UnionType *>(extended_class())
                   : nullptr;
    }
    const Metadata::StringLiteralType *extended_class_as_StringLiteral() const
    {
        return extended_class_type() == Metadata::TYPE_STRING_LITERAL
                   ? static_cast<const Metadata::StringLiteralType *>(extended_class())
                   : nullptr;
    }
    void *mutable_extended_class()
    {
        return GetPointer<void *>(VT_EXTENDED_CLASS);
    }
    const ::flatbuffers::Vector<uint8_t> *implemented_interfaces_type() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMPLEMENTED_INTERFACES_TYPE);
    }
    ::flatbuffers::Vector<uint8_t> *mutable_implemented_interfaces_type()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_IMPLEMENTED_INTERFACES_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *implemented_interfaces() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_IMPLEMENTED_INTERFACES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<void>> *mutable_implemented_interfaces()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_IMPLEMENTED_INTERFACES);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_METHODS) && verifier.VerifyVector(methods()) &&
               verifier.VerifyVectorOfTables(methods()) && VerifyOffset(verifier, VT_FIELDS) &&
               verifier.VerifyVector(fields()) && verifier.VerifyVectorOfTables(fields()) &&
               VerifyOffset(verifier, VT_PROPERTIES) && verifier.VerifyVector(properties()) &&
               verifier.VerifyVectorOfTables(properties()) && VerifyOffset(verifier, VT_TYPE_PARAMS) &&
               verifier.VerifyVector(type_params()) && verifier.VerifyVectorOfTables(type_params()) &&
               VerifyField<uint8_t>(verifier, VT_EXTENDED_CLASS_TYPE, 1) && VerifyOffset(verifier, VT_EXTENDED_CLASS) &&
               VerifyType(verifier, extended_class(), extended_class_type()) &&
               VerifyOffset(verifier, VT_IMPLEMENTED_INTERFACES_TYPE) &&
               verifier.VerifyVector(implemented_interfaces_type()) &&
               VerifyOffset(verifier, VT_IMPLEMENTED_INTERFACES) && verifier.VerifyVector(implemented_interfaces()) &&
               VerifyTypeVector(verifier, implemented_interfaces(), implemented_interfaces_type()) &&
               verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *ClassDecl::extended_class_as<Metadata::BuiltinType>() const
{
    return extended_class_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *ClassDecl::extended_class_as<Metadata::InternalTypeRef>() const
{
    return extended_class_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *ClassDecl::extended_class_as<Metadata::ExternalTypeRef>() const
{
    return extended_class_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *ClassDecl::extended_class_as<Metadata::FunctionType>() const
{
    return extended_class_as_Function();
}

template <>
inline const Metadata::TupleType *ClassDecl::extended_class_as<Metadata::TupleType>() const
{
    return extended_class_as_Tuple();
}

template <>
inline const Metadata::UnionType *ClassDecl::extended_class_as<Metadata::UnionType>() const
{
    return extended_class_as_Union();
}

template <>
inline const Metadata::StringLiteralType *ClassDecl::extended_class_as<Metadata::StringLiteralType>() const
{
    return extended_class_as_StringLiteral();
}

struct ClassDeclBuilder {
    typedef ClassDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(ClassDecl::VT_NAME, name);
    }
    void add_methods(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> methods)
    {
        fbb_.AddOffset(ClassDecl::VT_METHODS, methods);
    }
    void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>>> fields)
    {
        fbb_.AddOffset(ClassDecl::VT_FIELDS, fields);
    }
    void add_properties(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>>> properties)
    {
        fbb_.AddOffset(ClassDecl::VT_PROPERTIES, properties);
    }
    void add_type_params(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>>> type_params)
    {
        fbb_.AddOffset(ClassDecl::VT_TYPE_PARAMS, type_params);
    }
    void add_extended_class_type(Metadata::Type extended_class_type)
    {
        fbb_.AddElement<uint8_t>(ClassDecl::VT_EXTENDED_CLASS_TYPE, static_cast<uint8_t>(extended_class_type), 0);
    }
    void add_extended_class(::flatbuffers::Offset<void> extended_class)
    {
        fbb_.AddOffset(ClassDecl::VT_EXTENDED_CLASS, extended_class);
    }
    void add_implemented_interfaces_type(
        ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implemented_interfaces_type)
    {
        fbb_.AddOffset(ClassDecl::VT_IMPLEMENTED_INTERFACES_TYPE, implemented_interfaces_type);
    }
    void add_implemented_interfaces(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> implemented_interfaces)
    {
        fbb_.AddOffset(ClassDecl::VT_IMPLEMENTED_INTERFACES, implemented_interfaces);
    }
    explicit ClassDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ClassDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ClassDecl>(end);
        fbb_.Required(o, ClassDecl::VT_NAME);
        return o;
    }
};

// CC-OFFNXT(G.FUD.06) flatbuffers auto-generated code
inline ::flatbuffers::Offset<ClassDecl> CreateClassDecl(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::VarDecl>>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>>> properties = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>>> type_params = 0,
    Metadata::Type extended_class_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> extended_class = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implemented_interfaces_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> implemented_interfaces = 0)
{
    ClassDeclBuilder builder(_fbb);
    builder.add_implemented_interfaces(implemented_interfaces);
    builder.add_implemented_interfaces_type(implemented_interfaces_type);
    builder.add_extended_class(extended_class);
    builder.add_type_params(type_params);
    builder.add_properties(properties);
    builder.add_fields(fields);
    builder.add_methods(methods);
    builder.add_name(name);
    builder.add_extended_class_type(extended_class_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<ClassDecl> CreateClassDeclDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *methods = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::VarDecl>> *fields = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *properties = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *type_params = nullptr,
    Metadata::Type extended_class_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> extended_class = 0,
    const std::vector<uint8_t> *interfaces_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *interfaces = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::FunctionDecl>>(*methods) : 0;
    auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::VarDecl>>(*fields) : 0;
    auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::PropertyDecl>>(*properties) : 0;
    auto type_params__ =
        type_params ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::TypeParamDecl>>(*type_params) : 0;
    auto interfaces_type__ = interfaces_type ? _fbb.CreateVector<uint8_t>(*interfaces_type) : 0;
    auto interfaces__ = interfaces ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*interfaces) : 0;
    return Metadata::CreateClassDecl(_fbb, name__, methods__, fields__, properties__, type_params__,
                                     extended_class_type, extended_class, interfaces_type__, interfaces__);
}

struct InterfaceDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef InterfaceDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NAME = 4,
        VT_METHODS = 6,
        VT_PROPERTIES = 8,
        VT_TYPE_PARAMS = 10,
        VT_IMPLEMENTED_INTERFACES_TYPE = 12,
        VT_IMPLEMENTED_INTERFACES = 14
    };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *methods() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_METHODS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *mutable_methods()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_METHODS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *properties() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *>(VT_PROPERTIES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *mutable_properties()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *>(VT_PROPERTIES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *type_params() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *>(
            VT_TYPE_PARAMS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *mutable_type_params()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *>(VT_TYPE_PARAMS);
    }
    const ::flatbuffers::Vector<uint8_t> *implemented_interfaces_type() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMPLEMENTED_INTERFACES_TYPE);
    }
    ::flatbuffers::Vector<uint8_t> *mutable_implemented_interfaces_type()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_IMPLEMENTED_INTERFACES_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *implemented_interfaces() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_IMPLEMENTED_INTERFACES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<void>> *mutable_implemented_interfaces()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_IMPLEMENTED_INTERFACES);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_METHODS) && verifier.VerifyVector(methods()) &&
               verifier.VerifyVectorOfTables(methods()) && VerifyOffset(verifier, VT_PROPERTIES) &&
               verifier.VerifyVector(properties()) && verifier.VerifyVectorOfTables(properties()) &&
               VerifyOffset(verifier, VT_TYPE_PARAMS) && verifier.VerifyVector(type_params()) &&
               verifier.VerifyVectorOfTables(type_params()) && VerifyOffset(verifier, VT_IMPLEMENTED_INTERFACES_TYPE) &&
               verifier.VerifyVector(implemented_interfaces_type()) &&
               VerifyOffset(verifier, VT_IMPLEMENTED_INTERFACES) && verifier.VerifyVector(implemented_interfaces()) &&
               VerifyTypeVector(verifier, implemented_interfaces(), implemented_interfaces_type()) &&
               verifier.EndTable();
    }
};

struct InterfaceDeclBuilder {
    typedef InterfaceDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(InterfaceDecl::VT_NAME, name);
    }
    void add_methods(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> methods)
    {
        fbb_.AddOffset(InterfaceDecl::VT_METHODS, methods);
    }
    void add_properties(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>>> properties)
    {
        fbb_.AddOffset(InterfaceDecl::VT_PROPERTIES, properties);
    }
    void add_type_params(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>>> type_params)
    {
        fbb_.AddOffset(InterfaceDecl::VT_TYPE_PARAMS, type_params);
    }
    void add_implemented_interfaces_type(
        ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implemented_interfaces_type)
    {
        fbb_.AddOffset(InterfaceDecl::VT_IMPLEMENTED_INTERFACES_TYPE, implemented_interfaces_type);
    }
    void add_implemented_interfaces(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> implemented_interfaces)
    {
        fbb_.AddOffset(InterfaceDecl::VT_IMPLEMENTED_INTERFACES, implemented_interfaces);
    }
    explicit InterfaceDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<InterfaceDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<InterfaceDecl>(end);
        fbb_.Required(o, InterfaceDecl::VT_NAME);
        return o;
    }
};

inline ::flatbuffers::Offset<InterfaceDecl> CreateInterfaceDecl(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::PropertyDecl>>> properties = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>>> type_params = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implemented_interfaces_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> implemented_interfaces = 0)
{
    InterfaceDeclBuilder builder(_fbb);
    builder.add_implemented_interfaces(implemented_interfaces);
    builder.add_implemented_interfaces_type(implemented_interfaces_type);
    builder.add_type_params(type_params);
    builder.add_properties(properties);
    builder.add_methods(methods);
    builder.add_name(name);
    return builder.Finish();
}

inline ::flatbuffers::Offset<InterfaceDecl> CreateInterfaceDeclDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *methods = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::PropertyDecl>> *properties = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *type_params = nullptr,
    const std::vector<uint8_t> *interfaces_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *interfaces = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::FunctionDecl>>(*methods) : 0;
    auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::PropertyDecl>>(*properties) : 0;
    auto type_params__ =
        type_params ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::TypeParamDecl>>(*type_params) : 0;
    auto interfaces_type__ = interfaces_type ? _fbb.CreateVector<uint8_t>(*interfaces_type) : 0;
    auto interfaces__ = interfaces ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*interfaces) : 0;
    return Metadata::CreateInterfaceDecl(_fbb, name__, methods__, properties__, type_params__, interfaces_type__,
                                         interfaces__);
}

struct EnumDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef EnumDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_ENTRIES = 6 };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *entries() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ENTRIES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_entries()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ENTRIES);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_ENTRIES) && verifier.VerifyVector(entries()) &&
               verifier.VerifyVectorOfStrings(entries()) && verifier.EndTable();
    }
};

struct EnumDeclBuilder {
    typedef EnumDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(EnumDecl::VT_NAME, name);
    }
    void add_entries(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> entries)
    {
        fbb_.AddOffset(EnumDecl::VT_ENTRIES, entries);
    }
    explicit EnumDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<EnumDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<EnumDecl>(end);
        fbb_.Required(o, EnumDecl::VT_NAME);
        return o;
    }
};

inline ::flatbuffers::Offset<EnumDecl> CreateEnumDecl(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> entries = 0)
{
    EnumDeclBuilder builder(_fbb);
    builder.add_entries(entries);
    builder.add_name(name);
    return builder.Finish();
}

inline ::flatbuffers::Offset<EnumDecl> CreateEnumDeclDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *entries = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto entries__ = entries ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*entries) : 0;
    return Metadata::CreateEnumDecl(_fbb, name__, entries__);
}

struct AnnotationDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef AnnotationDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4 };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               verifier.EndTable();
    }
};

struct AnnotationDeclBuilder {
    typedef AnnotationDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(AnnotationDecl::VT_NAME, name);
    }
    explicit AnnotationDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<AnnotationDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<AnnotationDecl>(end);
        fbb_.Required(o, AnnotationDecl::VT_NAME);
        return o;
    }
};

inline ::flatbuffers::Offset<AnnotationDecl> CreateAnnotationDecl(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                  ::flatbuffers::Offset<::flatbuffers::String> name = 0)
{
    AnnotationDeclBuilder builder(_fbb);
    builder.add_name(name);
    return builder.Finish();
}

inline ::flatbuffers::Offset<AnnotationDecl> CreateAnnotationDeclDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                        const char *name = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return Metadata::CreateAnnotationDecl(_fbb, name__);
}

struct TypeDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef TypeDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TYPE_TYPE = 4, VT_TYPE = 6 };
    Metadata::Type type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
    }
    const void *type() const
    {
        return GetPointer<const void *>(VT_TYPE);
    }
    template <typename T>
    const T *type_as() const;
    const Metadata::BuiltinType *type_as_Builtin() const
    {
        return type_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(type()) : nullptr;
    }
    const Metadata::InternalTypeRef *type_as_RefInternal() const
    {
        return type_type() == Metadata::TYPE_REF_INTERNAL ? static_cast<const Metadata::InternalTypeRef *>(type())
                                                          : nullptr;
    }
    const Metadata::ExternalTypeRef *type_as_RefExternal() const
    {
        return type_type() == Metadata::TYPE_REF_EXTERNAL ? static_cast<const Metadata::ExternalTypeRef *>(type())
                                                          : nullptr;
    }
    const Metadata::FunctionType *type_as_Function() const
    {
        return type_type() == Metadata::TYPE_FUNCTION ? static_cast<const Metadata::FunctionType *>(type()) : nullptr;
    }
    const Metadata::TupleType *type_as_Tuple() const
    {
        return type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(type()) : nullptr;
    }
    const Metadata::UnionType *type_as_Union() const
    {
        return type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(type()) : nullptr;
    }
    const Metadata::StringLiteralType *type_as_StringLiteral() const
    {
        return type_type() == Metadata::TYPE_STRING_LITERAL ? static_cast<const Metadata::StringLiteralType *>(type())
                                                            : nullptr;
    }
    void *mutable_type()
    {
        return GetPointer<void *>(VT_TYPE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TYPE_TYPE, 1) &&
               VerifyOffsetRequired(verifier, VT_TYPE) && VerifyType(verifier, type(), type_type()) &&
               verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *TypeDecl::type_as<Metadata::BuiltinType>() const
{
    return type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *TypeDecl::type_as<Metadata::InternalTypeRef>() const
{
    return type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *TypeDecl::type_as<Metadata::ExternalTypeRef>() const
{
    return type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *TypeDecl::type_as<Metadata::FunctionType>() const
{
    return type_as_Function();
}

template <>
inline const Metadata::TupleType *TypeDecl::type_as<Metadata::TupleType>() const
{
    return type_as_Tuple();
}

template <>
inline const Metadata::UnionType *TypeDecl::type_as<Metadata::UnionType>() const
{
    return type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *TypeDecl::type_as<Metadata::StringLiteralType>() const
{
    return type_as_StringLiteral();
}

struct TypeDeclBuilder {
    typedef TypeDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_type_type(Metadata::Type type_type)
    {
        fbb_.AddElement<uint8_t>(TypeDecl::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
    }
    void add_type(::flatbuffers::Offset<void> type)
    {
        fbb_.AddOffset(TypeDecl::VT_TYPE, type);
    }
    explicit TypeDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TypeDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TypeDecl>(end);
        fbb_.Required(o, TypeDecl::VT_TYPE);
        return o;
    }
};

inline ::flatbuffers::Offset<TypeDecl> CreateTypeDecl(::flatbuffers::FlatBufferBuilder &_fbb,
                                                      Metadata::Type type_type = Metadata::TYPE_NONE,
                                                      ::flatbuffers::Offset<void> type = 0)
{
    TypeDeclBuilder builder(_fbb);
    builder.add_type(type);
    builder.add_type_type(type_type);
    return builder.Finish();
}

struct FunctionDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FunctionDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NAME = 4,
        VT_RETURN_TYPE_TYPE = 6,
        VT_RETURN_TYPE = 8,
        VT_VALUE_PARAMS = 10,
        VT_TYPE_PARAMS = 12,
        VT_OVERLOADS = 14
    };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    Metadata::Type return_type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_RETURN_TYPE_TYPE, 0));
    }
    const void *return_type() const
    {
        return GetPointer<const void *>(VT_RETURN_TYPE);
    }
    template <typename T>
    const T *return_type_as() const;
    const Metadata::BuiltinType *return_type_as_Builtin() const
    {
        return return_type_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(return_type())
                                                            : nullptr;
    }
    const Metadata::InternalTypeRef *return_type_as_RefInternal() const
    {
        return return_type_type() == Metadata::TYPE_REF_INTERNAL
                   ? static_cast<const Metadata::InternalTypeRef *>(return_type())
                   : nullptr;
    }
    const Metadata::ExternalTypeRef *return_type_as_RefExternal() const
    {
        return return_type_type() == Metadata::TYPE_REF_EXTERNAL
                   ? static_cast<const Metadata::ExternalTypeRef *>(return_type())
                   : nullptr;
    }
    const Metadata::FunctionType *return_type_as_Function() const
    {
        return return_type_type() == Metadata::TYPE_FUNCTION
                   ? static_cast<const Metadata::FunctionType *>(return_type())
                   : nullptr;
    }
    const Metadata::TupleType *return_type_as_Tuple() const
    {
        return return_type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(return_type())
                                                          : nullptr;
    }
    const Metadata::UnionType *return_type_as_Union() const
    {
        return return_type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(return_type())
                                                          : nullptr;
    }
    const Metadata::StringLiteralType *return_type_as_StringLiteral() const
    {
        return return_type_type() == Metadata::TYPE_STRING_LITERAL
                   ? static_cast<const Metadata::StringLiteralType *>(return_type())
                   : nullptr;
    }
    void *mutable_return_type()
    {
        return GetPointer<void *>(VT_RETURN_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ValueParamDecl>> *value_params() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ValueParamDecl>> *>(
            VT_VALUE_PARAMS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ValueParamDecl>> *mutable_value_params()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ValueParamDecl>> *>(VT_VALUE_PARAMS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *type_params() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *>(
            VT_TYPE_PARAMS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *mutable_type_params()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *>(VT_TYPE_PARAMS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *overloads() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_OVERLOADS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *mutable_overloads()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *>(VT_OVERLOADS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyField<uint8_t>(verifier, VT_RETURN_TYPE_TYPE, 1) && VerifyOffset(verifier, VT_RETURN_TYPE) &&
               VerifyType(verifier, return_type(), return_type_type()) && VerifyOffset(verifier, VT_VALUE_PARAMS) &&
               verifier.VerifyVector(value_params()) && verifier.VerifyVectorOfTables(value_params()) &&
               VerifyOffset(verifier, VT_TYPE_PARAMS) && verifier.VerifyVector(type_params()) &&
               verifier.VerifyVectorOfTables(type_params()) && VerifyOffset(verifier, VT_OVERLOADS) &&
               verifier.VerifyVector(overloads()) && verifier.VerifyVectorOfTables(overloads()) && verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *FunctionDecl::return_type_as<Metadata::BuiltinType>() const
{
    return return_type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *FunctionDecl::return_type_as<Metadata::InternalTypeRef>() const
{
    return return_type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *FunctionDecl::return_type_as<Metadata::ExternalTypeRef>() const
{
    return return_type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *FunctionDecl::return_type_as<Metadata::FunctionType>() const
{
    return return_type_as_Function();
}

template <>
inline const Metadata::TupleType *FunctionDecl::return_type_as<Metadata::TupleType>() const
{
    return return_type_as_Tuple();
}

template <>
inline const Metadata::UnionType *FunctionDecl::return_type_as<Metadata::UnionType>() const
{
    return return_type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *FunctionDecl::return_type_as<Metadata::StringLiteralType>() const
{
    return return_type_as_StringLiteral();
}

struct FunctionDeclBuilder {
    typedef FunctionDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(FunctionDecl::VT_NAME, name);
    }
    void add_return_type_type(Metadata::Type return_type_type)
    {
        fbb_.AddElement<uint8_t>(FunctionDecl::VT_RETURN_TYPE_TYPE, static_cast<uint8_t>(return_type_type), 0);
    }
    void add_return_type(::flatbuffers::Offset<void> return_type)
    {
        fbb_.AddOffset(FunctionDecl::VT_RETURN_TYPE, return_type);
    }
    void add_value_params(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ValueParamDecl>>> value_params)
    {
        fbb_.AddOffset(FunctionDecl::VT_VALUE_PARAMS, value_params);
    }
    void add_type_params(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>>> type_params)
    {
        fbb_.AddOffset(FunctionDecl::VT_TYPE_PARAMS, type_params);
    }
    void add_overloads(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> overloads)
    {
        fbb_.AddOffset(FunctionDecl::VT_OVERLOADS, overloads);
    }
    explicit FunctionDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FunctionDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FunctionDecl>(end);
        fbb_.Required(o, FunctionDecl::VT_NAME);
        return o;
    }
};

inline ::flatbuffers::Offset<FunctionDecl> CreateFunctionDecl(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    Metadata::Type return_type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> return_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::ValueParamDecl>>> value_params = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::TypeParamDecl>>> type_params = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionDecl>>> overloads = 0)
{
    FunctionDeclBuilder builder(_fbb);
    builder.add_overloads(overloads);
    builder.add_type_params(type_params);
    builder.add_value_params(value_params);
    builder.add_return_type(return_type);
    builder.add_name(name);
    builder.add_return_type_type(return_type_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<FunctionDecl> CreateFunctionDeclDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    Metadata::Type return_type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> return_type = 0,
    const std::vector<::flatbuffers::Offset<Metadata::ValueParamDecl>> *value_params = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::TypeParamDecl>> *type_params = nullptr,
    const std::vector<::flatbuffers::Offset<Metadata::FunctionDecl>> *overloads = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto value_params__ =
        value_params ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::ValueParamDecl>>(*value_params) : 0;
    auto type_params__ =
        type_params ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::TypeParamDecl>>(*type_params) : 0;
    auto overloads__ = overloads ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::FunctionDecl>>(*overloads) : 0;
    return Metadata::CreateFunctionDecl(_fbb, name__, return_type_type, return_type, value_params__, type_params__,
                                        overloads__);
}

struct VarDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef VarDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NAME = 4,
        VT_RETURN_TYPE_TYPE = 6,
        VT_RETURN_TYPE = 8
    };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    Metadata::Type return_type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_RETURN_TYPE_TYPE, 0));
    }
    const void *return_type() const
    {
        return GetPointer<const void *>(VT_RETURN_TYPE);
    }
    template <typename T>
    const T *return_type_as() const;
    const Metadata::BuiltinType *return_type_as_Builtin() const
    {
        return return_type_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(return_type())
                                                            : nullptr;
    }
    const Metadata::InternalTypeRef *return_type_as_RefInternal() const
    {
        return return_type_type() == Metadata::TYPE_REF_INTERNAL
                   ? static_cast<const Metadata::InternalTypeRef *>(return_type())
                   : nullptr;
    }
    const Metadata::ExternalTypeRef *return_type_as_RefExternal() const
    {
        return return_type_type() == Metadata::TYPE_REF_EXTERNAL
                   ? static_cast<const Metadata::ExternalTypeRef *>(return_type())
                   : nullptr;
    }
    const Metadata::FunctionType *return_type_as_Function() const
    {
        return return_type_type() == Metadata::TYPE_FUNCTION
                   ? static_cast<const Metadata::FunctionType *>(return_type())
                   : nullptr;
    }
    const Metadata::TupleType *return_type_as_Tuple() const
    {
        return return_type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(return_type())
                                                          : nullptr;
    }
    const Metadata::UnionType *return_type_as_Union() const
    {
        return return_type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(return_type())
                                                          : nullptr;
    }
    const Metadata::StringLiteralType *return_type_as_StringLiteral() const
    {
        return return_type_type() == Metadata::TYPE_STRING_LITERAL
                   ? static_cast<const Metadata::StringLiteralType *>(return_type())
                   : nullptr;
    }
    void *mutable_return_type()
    {
        return GetPointer<void *>(VT_RETURN_TYPE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyField<uint8_t>(verifier, VT_RETURN_TYPE_TYPE, 1) &&
               VerifyOffsetRequired(verifier, VT_RETURN_TYPE) &&
               VerifyType(verifier, return_type(), return_type_type()) && verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *VarDecl::return_type_as<Metadata::BuiltinType>() const
{
    return return_type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *VarDecl::return_type_as<Metadata::InternalTypeRef>() const
{
    return return_type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *VarDecl::return_type_as<Metadata::ExternalTypeRef>() const
{
    return return_type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *VarDecl::return_type_as<Metadata::FunctionType>() const
{
    return return_type_as_Function();
}

template <>
inline const Metadata::TupleType *VarDecl::return_type_as<Metadata::TupleType>() const
{
    return return_type_as_Tuple();
}

template <>
inline const Metadata::UnionType *VarDecl::return_type_as<Metadata::UnionType>() const
{
    return return_type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *VarDecl::return_type_as<Metadata::StringLiteralType>() const
{
    return return_type_as_StringLiteral();
}

struct VarDeclBuilder {
    typedef VarDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(VarDecl::VT_NAME, name);
    }
    void add_return_type_type(Metadata::Type return_type_type)
    {
        fbb_.AddElement<uint8_t>(VarDecl::VT_RETURN_TYPE_TYPE, static_cast<uint8_t>(return_type_type), 0);
    }
    void add_return_type(::flatbuffers::Offset<void> return_type)
    {
        fbb_.AddOffset(VarDecl::VT_RETURN_TYPE, return_type);
    }
    explicit VarDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<VarDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<VarDecl>(end);
        fbb_.Required(o, VarDecl::VT_NAME);
        fbb_.Required(o, VarDecl::VT_RETURN_TYPE);
        return o;
    }
};

inline ::flatbuffers::Offset<VarDecl> CreateVarDecl(::flatbuffers::FlatBufferBuilder &_fbb,
                                                    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
                                                    Metadata::Type return_type_type = Metadata::TYPE_NONE,
                                                    ::flatbuffers::Offset<void> return_type = 0)
{
    VarDeclBuilder builder(_fbb);
    builder.add_return_type(return_type);
    builder.add_name(name);
    builder.add_return_type_type(return_type_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<VarDecl> CreateVarDeclDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                          const char *name = nullptr,
                                                          Metadata::Type return_type_type = Metadata::TYPE_NONE,
                                                          ::flatbuffers::Offset<void> return_type = 0)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return Metadata::CreateVarDecl(_fbb, name__, return_type_type, return_type);
}

struct PropertyDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef PropertyDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_GETTER = 4, VT_SETTER = 6 };
    const Metadata::FunctionDecl *getter() const
    {
        return GetPointer<const Metadata::FunctionDecl *>(VT_GETTER);
    }
    Metadata::FunctionDecl *mutable_getter()
    {
        return GetPointer<Metadata::FunctionDecl *>(VT_GETTER);
    }
    const Metadata::FunctionDecl *setter() const
    {
        return GetPointer<const Metadata::FunctionDecl *>(VT_SETTER);
    }
    Metadata::FunctionDecl *mutable_setter()
    {
        return GetPointer<Metadata::FunctionDecl *>(VT_SETTER);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_GETTER) && verifier.VerifyTable(getter()) &&
               VerifyOffset(verifier, VT_SETTER) && verifier.VerifyTable(setter()) && verifier.EndTable();
    }
};

struct PropertyDeclBuilder {
    typedef PropertyDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_getter(::flatbuffers::Offset<Metadata::FunctionDecl> getter)
    {
        fbb_.AddOffset(PropertyDecl::VT_GETTER, getter);
    }
    void add_setter(::flatbuffers::Offset<Metadata::FunctionDecl> setter)
    {
        fbb_.AddOffset(PropertyDecl::VT_SETTER, setter);
    }
    explicit PropertyDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<PropertyDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<PropertyDecl>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<PropertyDecl> CreatePropertyDecl(::flatbuffers::FlatBufferBuilder &_fbb,
                                                              ::flatbuffers::Offset<Metadata::FunctionDecl> getter = 0,
                                                              ::flatbuffers::Offset<Metadata::FunctionDecl> setter = 0)
{
    PropertyDeclBuilder builder(_fbb);
    builder.add_setter(setter);
    builder.add_getter(getter);
    return builder.Finish();
}

struct ValueParamDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ValueParamDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NAME = 4,
        VT_TYPE_TYPE = 6,
        VT_TYPE = 8,
        VT_IS_READONLY = 10
    };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    Metadata::Type type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
    }
    const void *type() const
    {
        return GetPointer<const void *>(VT_TYPE);
    }
    template <typename T>
    const T *type_as() const;
    const Metadata::BuiltinType *type_as_Builtin() const
    {
        return type_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(type()) : nullptr;
    }
    const Metadata::InternalTypeRef *type_as_RefInternal() const
    {
        return type_type() == Metadata::TYPE_REF_INTERNAL ? static_cast<const Metadata::InternalTypeRef *>(type())
                                                          : nullptr;
    }
    const Metadata::ExternalTypeRef *type_as_RefExternal() const
    {
        return type_type() == Metadata::TYPE_REF_EXTERNAL ? static_cast<const Metadata::ExternalTypeRef *>(type())
                                                          : nullptr;
    }
    const Metadata::FunctionType *type_as_Function() const
    {
        return type_type() == Metadata::TYPE_FUNCTION ? static_cast<const Metadata::FunctionType *>(type()) : nullptr;
    }
    const Metadata::TupleType *type_as_Tuple() const
    {
        return type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(type()) : nullptr;
    }
    const Metadata::UnionType *type_as_Union() const
    {
        return type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(type()) : nullptr;
    }
    const Metadata::StringLiteralType *type_as_StringLiteral() const
    {
        return type_type() == Metadata::TYPE_STRING_LITERAL ? static_cast<const Metadata::StringLiteralType *>(type())
                                                            : nullptr;
    }
    void *mutable_type()
    {
        return GetPointer<void *>(VT_TYPE);
    }
    bool is_readonly() const
    {
        return GetField<uint8_t>(VT_IS_READONLY, 0) != 0;
    }
    bool mutate_is_readonly(bool _is_readonly = 0)
    {
        return SetField<uint8_t>(VT_IS_READONLY, static_cast<uint8_t>(_is_readonly), 0);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyField<uint8_t>(verifier, VT_TYPE_TYPE, 1) && VerifyOffsetRequired(verifier, VT_TYPE) &&
               VerifyType(verifier, type(), type_type()) && VerifyField<uint8_t>(verifier, VT_IS_READONLY, 1) &&
               verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *ValueParamDecl::type_as<Metadata::BuiltinType>() const
{
    return type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *ValueParamDecl::type_as<Metadata::InternalTypeRef>() const
{
    return type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *ValueParamDecl::type_as<Metadata::ExternalTypeRef>() const
{
    return type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *ValueParamDecl::type_as<Metadata::FunctionType>() const
{
    return type_as_Function();
}

template <>
inline const Metadata::TupleType *ValueParamDecl::type_as<Metadata::TupleType>() const
{
    return type_as_Tuple();
}

template <>
inline const Metadata::UnionType *ValueParamDecl::type_as<Metadata::UnionType>() const
{
    return type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *ValueParamDecl::type_as<Metadata::StringLiteralType>() const
{
    return type_as_StringLiteral();
}

struct ValueParamDeclBuilder {
    typedef ValueParamDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(ValueParamDecl::VT_NAME, name);
    }
    void add_type_type(Metadata::Type type_type)
    {
        fbb_.AddElement<uint8_t>(ValueParamDecl::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
    }
    void add_type(::flatbuffers::Offset<void> type)
    {
        fbb_.AddOffset(ValueParamDecl::VT_TYPE, type);
    }
    void add_is_readonly(bool is_readonly)
    {
        fbb_.AddElement<uint8_t>(ValueParamDecl::VT_IS_READONLY, static_cast<uint8_t>(is_readonly), 0);
    }
    explicit ValueParamDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ValueParamDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ValueParamDecl>(end);
        fbb_.Required(o, ValueParamDecl::VT_NAME);
        fbb_.Required(o, ValueParamDecl::VT_TYPE);
        return o;
    }
};

inline ::flatbuffers::Offset<ValueParamDecl> CreateValueParamDecl(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                  ::flatbuffers::Offset<::flatbuffers::String> name = 0,
                                                                  Metadata::Type type_type = Metadata::TYPE_NONE,
                                                                  ::flatbuffers::Offset<void> type = 0,
                                                                  bool is_readonly = false)
{
    ValueParamDeclBuilder builder(_fbb);
    builder.add_type(type);
    builder.add_name(name);
    builder.add_is_readonly(is_readonly);
    builder.add_type_type(type_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<ValueParamDecl> CreateValueParamDeclDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                        const char *name = nullptr,
                                                                        Metadata::Type type_type = Metadata::TYPE_NONE,
                                                                        ::flatbuffers::Offset<void> type = 0,
                                                                        bool is_readonly = false)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return Metadata::CreateValueParamDecl(_fbb, name__, type_type, type, is_readonly);
}

struct TypeParamDecl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef TypeParamDeclBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NAME = 4,
        VT_VARIANCE = 6,
        VT_CONSTRAINT_TYPE = 8,
        VT_CONSTRAINT = 10,
        VT_DEFAULT_TYPE_TYPE = 12,
        VT_DEFAULT_TYPE = 14
    };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    Metadata::TypeParamVariance variance() const
    {
        return static_cast<Metadata::TypeParamVariance>(GetField<int8_t>(VT_VARIANCE, 0));
    }
    bool mutate_variance(Metadata::TypeParamVariance _variance = static_cast<Metadata::TypeParamVariance>(0))
    {
        return SetField<int8_t>(VT_VARIANCE, static_cast<int8_t>(_variance), 0);
    }
    Metadata::Type constraint_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_CONSTRAINT_TYPE, 0));
    }
    const void *constraint() const
    {
        return GetPointer<const void *>(VT_CONSTRAINT);
    }
    template <typename T>
    const T *constraint_as() const;
    const Metadata::BuiltinType *constraint_as_Builtin() const
    {
        return constraint_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(constraint())
                                                           : nullptr;
    }
    const Metadata::InternalTypeRef *constraint_as_RefInternal() const
    {
        return constraint_type() == Metadata::TYPE_REF_INTERNAL
                   ? static_cast<const Metadata::InternalTypeRef *>(constraint())
                   : nullptr;
    }
    const Metadata::ExternalTypeRef *constraint_as_RefExternal() const
    {
        return constraint_type() == Metadata::TYPE_REF_EXTERNAL
                   ? static_cast<const Metadata::ExternalTypeRef *>(constraint())
                   : nullptr;
    }
    const Metadata::FunctionType *constraint_as_Function() const
    {
        return constraint_type() == Metadata::TYPE_FUNCTION ? static_cast<const Metadata::FunctionType *>(constraint())
                                                            : nullptr;
    }
    const Metadata::TupleType *constraint_as_Tuple() const
    {
        return constraint_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(constraint())
                                                         : nullptr;
    }
    const Metadata::UnionType *constraint_as_Union() const
    {
        return constraint_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(constraint())
                                                         : nullptr;
    }
    const Metadata::StringLiteralType *constraint_as_StringLiteral() const
    {
        return constraint_type() == Metadata::TYPE_STRING_LITERAL
                   ? static_cast<const Metadata::StringLiteralType *>(constraint())
                   : nullptr;
    }
    void *mutable_constraint()
    {
        return GetPointer<void *>(VT_CONSTRAINT);
    }
    Metadata::Type default_type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_DEFAULT_TYPE_TYPE, 0));
    }
    const void *default_type() const
    {
        return GetPointer<const void *>(VT_DEFAULT_TYPE);
    }
    template <typename T>
    const T *default_type_as() const;
    const Metadata::BuiltinType *default_type_as_Builtin() const
    {
        return default_type_type() == Metadata::TYPE_BUILTIN
                   ? static_cast<const Metadata::BuiltinType *>(default_type())
                   : nullptr;
    }
    const Metadata::InternalTypeRef *default_type_as_RefInternal() const
    {
        return default_type_type() == Metadata::TYPE_REF_INTERNAL
                   ? static_cast<const Metadata::InternalTypeRef *>(default_type())
                   : nullptr;
    }
    const Metadata::ExternalTypeRef *default_type_as_RefExternal() const
    {
        return default_type_type() == Metadata::TYPE_REF_EXTERNAL
                   ? static_cast<const Metadata::ExternalTypeRef *>(default_type())
                   : nullptr;
    }
    const Metadata::FunctionType *default_type_as_Function() const
    {
        return default_type_type() == Metadata::TYPE_FUNCTION
                   ? static_cast<const Metadata::FunctionType *>(default_type())
                   : nullptr;
    }
    const Metadata::TupleType *default_type_as_Tuple() const
    {
        return default_type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(default_type())
                                                           : nullptr;
    }
    const Metadata::UnionType *default_type_as_Union() const
    {
        return default_type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(default_type())
                                                           : nullptr;
    }
    const Metadata::StringLiteralType *default_type_as_StringLiteral() const
    {
        return default_type_type() == Metadata::TYPE_STRING_LITERAL
                   ? static_cast<const Metadata::StringLiteralType *>(default_type())
                   : nullptr;
    }
    void *mutable_default_type()
    {
        return GetPointer<void *>(VT_DEFAULT_TYPE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyField<int8_t>(verifier, VT_VARIANCE, 1) && VerifyField<uint8_t>(verifier, VT_CONSTRAINT_TYPE, 1) &&
               VerifyOffset(verifier, VT_CONSTRAINT) && VerifyType(verifier, constraint(), constraint_type()) &&
               VerifyField<uint8_t>(verifier, VT_DEFAULT_TYPE_TYPE, 1) && VerifyOffset(verifier, VT_DEFAULT_TYPE) &&
               VerifyType(verifier, default_type(), default_type_type()) && verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *TypeParamDecl::constraint_as<Metadata::BuiltinType>() const
{
    return constraint_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *TypeParamDecl::constraint_as<Metadata::InternalTypeRef>() const
{
    return constraint_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *TypeParamDecl::constraint_as<Metadata::ExternalTypeRef>() const
{
    return constraint_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *TypeParamDecl::constraint_as<Metadata::FunctionType>() const
{
    return constraint_as_Function();
}

template <>
inline const Metadata::TupleType *TypeParamDecl::constraint_as<Metadata::TupleType>() const
{
    return constraint_as_Tuple();
}

template <>
inline const Metadata::UnionType *TypeParamDecl::constraint_as<Metadata::UnionType>() const
{
    return constraint_as_Union();
}

template <>
inline const Metadata::StringLiteralType *TypeParamDecl::constraint_as<Metadata::StringLiteralType>() const
{
    return constraint_as_StringLiteral();
}

template <>
inline const Metadata::BuiltinType *TypeParamDecl::default_type_as<Metadata::BuiltinType>() const
{
    return default_type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *TypeParamDecl::default_type_as<Metadata::InternalTypeRef>() const
{
    return default_type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *TypeParamDecl::default_type_as<Metadata::ExternalTypeRef>() const
{
    return default_type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *TypeParamDecl::default_type_as<Metadata::FunctionType>() const
{
    return default_type_as_Function();
}

template <>
inline const Metadata::TupleType *TypeParamDecl::default_type_as<Metadata::TupleType>() const
{
    return default_type_as_Tuple();
}

template <>
inline const Metadata::UnionType *TypeParamDecl::default_type_as<Metadata::UnionType>() const
{
    return default_type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *TypeParamDecl::default_type_as<Metadata::StringLiteralType>() const
{
    return default_type_as_StringLiteral();
}

struct TypeParamDeclBuilder {
    typedef TypeParamDecl Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(TypeParamDecl::VT_NAME, name);
    }
    void add_variance(Metadata::TypeParamVariance variance)
    {
        fbb_.AddElement<int8_t>(TypeParamDecl::VT_VARIANCE, static_cast<int8_t>(variance), 0);
    }
    void add_constraint_type(Metadata::Type constraint_type)
    {
        fbb_.AddElement<uint8_t>(TypeParamDecl::VT_CONSTRAINT_TYPE, static_cast<uint8_t>(constraint_type), 0);
    }
    void add_constraint(::flatbuffers::Offset<void> constraint)
    {
        fbb_.AddOffset(TypeParamDecl::VT_CONSTRAINT, constraint);
    }
    void add_default_type_type(Metadata::Type default_type_type)
    {
        fbb_.AddElement<uint8_t>(TypeParamDecl::VT_DEFAULT_TYPE_TYPE, static_cast<uint8_t>(default_type_type), 0);
    }
    void add_default_type(::flatbuffers::Offset<void> default_type)
    {
        fbb_.AddOffset(TypeParamDecl::VT_DEFAULT_TYPE, default_type);
    }
    explicit TypeParamDeclBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TypeParamDecl> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TypeParamDecl>(end);
        fbb_.Required(o, TypeParamDecl::VT_NAME);
        return o;
    }
};

inline ::flatbuffers::Offset<TypeParamDecl> CreateTypeParamDecl(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    Metadata::TypeParamVariance variance = Metadata::TYPE_PARAM_VARIANCE_INV,
    Metadata::Type constraint_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> constraint = 0,
    Metadata::Type default_type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> default_type = 0)
{
    TypeParamDeclBuilder builder(_fbb);
    builder.add_default_type(default_type);
    builder.add_constraint(constraint);
    builder.add_name(name);
    builder.add_default_type_type(default_type_type);
    builder.add_constraint_type(constraint_type);
    builder.add_variance(variance);
    return builder.Finish();
}

inline ::flatbuffers::Offset<TypeParamDecl> CreateTypeParamDeclDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    Metadata::TypeParamVariance variance = Metadata::TYPE_PARAM_VARIANCE_INV,
    Metadata::Type constraint_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> constraint = 0,
    Metadata::Type default_type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> default_type = 0)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return Metadata::CreateTypeParamDecl(_fbb, name__, variance, constraint_type, constraint, default_type_type,
                                         default_type);
}

struct BuiltinType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef BuiltinTypeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_KIND = 4,
        VT_TYPE_ARGS_TYPE = 6,
        VT_TYPE_ARGS = 8
    };
    Metadata::BuiltinTypeKind kind() const
    {
        return static_cast<Metadata::BuiltinTypeKind>(GetField<int8_t>(VT_KIND, 0));
    }
    bool mutate_kind(Metadata::BuiltinTypeKind _kind = static_cast<Metadata::BuiltinTypeKind>(0))
    {
        return SetField<int8_t>(VT_KIND, static_cast<int8_t>(_kind), 0);
    }
    const ::flatbuffers::Vector<uint8_t> *type_args_type() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_TYPE_ARGS_TYPE);
    }
    ::flatbuffers::Vector<uint8_t> *mutable_type_args_type()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_TYPE_ARGS_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *type_args() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_TYPE_ARGS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<void>> *mutable_type_args()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_TYPE_ARGS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_KIND, 1) &&
               VerifyOffset(verifier, VT_TYPE_ARGS_TYPE) && verifier.VerifyVector(type_args_type()) &&
               VerifyOffset(verifier, VT_TYPE_ARGS) && verifier.VerifyVector(type_args()) &&
               VerifyTypeVector(verifier, type_args(), type_args_type()) && verifier.EndTable();
    }
};

struct BuiltinTypeBuilder {
    typedef BuiltinType Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void AddKind(Metadata::BuiltinTypeKind kind)
    {
        fbb_.AddElement<int8_t>(BuiltinType::VT_KIND, static_cast<int8_t>(kind), 0);
    }
    void AddTypeArgsType(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> type_args_type)
    {
        fbb_.AddOffset(BuiltinType::VT_TYPE_ARGS_TYPE, type_args_type);
    }
    void AddTypeArgs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> type_args)
    {
        fbb_.AddOffset(BuiltinType::VT_TYPE_ARGS, type_args);
    }
    explicit BuiltinTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<BuiltinType> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<BuiltinType>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<BuiltinType> CreateBuiltinType(
    ::flatbuffers::FlatBufferBuilder &_fbb, Metadata::BuiltinTypeKind kind = Metadata::BUILTIN_TYPE_KIND_BYTE,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> type_args_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> type_args = 0)
{
    BuiltinTypeBuilder builder(_fbb);
    builder.AddTypeArgs(type_args);
    builder.AddTypeArgsType(type_args_type);
    builder.AddKind(kind);
    return builder.Finish();
}

inline ::flatbuffers::Offset<BuiltinType> CreateBuiltinTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, Metadata::BuiltinTypeKind kind = Metadata::BUILTIN_TYPE_KIND_BYTE,
    const std::vector<uint8_t> *type_args_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *type_args = nullptr)
{
    auto type_args_type__ = type_args_type ? _fbb.CreateVector<uint8_t>(*type_args_type) : 0;
    auto type_args__ = type_args ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*type_args) : 0;
    return Metadata::CreateBuiltinType(_fbb, kind, type_args_type__, type_args__);
}

struct InternalTypeRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef InternalTypeRefBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DECL_TYPE = 4, VT_DECL = 6 };
    Metadata::RefType decl_type() const
    {
        return static_cast<Metadata::RefType>(GetField<uint8_t>(VT_DECL_TYPE, 0));
    }
    const void *decl() const
    {
        return GetPointer<const void *>(VT_DECL);
    }
    template <typename T>
    const T *decl_as() const;
    const Metadata::ClassDecl *decl_as_class_() const
    {
        return decl_type() == Metadata::REF_TYPE_CLASS ? static_cast<const Metadata::ClassDecl *>(decl()) : nullptr;
    }
    const Metadata::InterfaceDecl *decl_as_interface() const
    {
        return decl_type() == Metadata::REF_TYPE_INTERFACE ? static_cast<const Metadata::InterfaceDecl *>(decl())
                                                           : nullptr;
    }
    const Metadata::EnumDecl *decl_as_enum_() const
    {
        return decl_type() == Metadata::REF_TYPE_ENUM ? static_cast<const Metadata::EnumDecl *>(decl()) : nullptr;
    }
    const Metadata::AnnotationDecl *decl_as_annotation() const
    {
        return decl_type() == Metadata::REF_TYPE_ANNOTATION ? static_cast<const Metadata::AnnotationDecl *>(decl())
                                                            : nullptr;
    }
    const Metadata::TypeDecl *decl_as_type() const
    {
        return decl_type() == Metadata::REF_TYPE_TYPE ? static_cast<const Metadata::TypeDecl *>(decl()) : nullptr;
    }
    const Metadata::TypeParamDecl *decl_as_typeParam() const
    {
        return decl_type() == Metadata::REF_TYPE_TYPE_PARAM ? static_cast<const Metadata::TypeParamDecl *>(decl())
                                                            : nullptr;
    }
    void *mutable_decl()
    {
        return GetPointer<void *>(VT_DECL);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_DECL_TYPE, 1) &&
               VerifyOffsetRequired(verifier, VT_DECL) && VerifyRefType(verifier, decl(), decl_type()) &&
               verifier.EndTable();
    }
};

template <>
inline const Metadata::ClassDecl *InternalTypeRef::decl_as<Metadata::ClassDecl>() const
{
    return decl_as_class_();
}

template <>
inline const Metadata::InterfaceDecl *InternalTypeRef::decl_as<Metadata::InterfaceDecl>() const
{
    return decl_as_interface();
}

template <>
inline const Metadata::EnumDecl *InternalTypeRef::decl_as<Metadata::EnumDecl>() const
{
    return decl_as_enum_();
}

template <>
inline const Metadata::AnnotationDecl *InternalTypeRef::decl_as<Metadata::AnnotationDecl>() const
{
    return decl_as_annotation();
}

template <>
inline const Metadata::TypeDecl *InternalTypeRef::decl_as<Metadata::TypeDecl>() const
{
    return decl_as_type();
}

template <>
inline const Metadata::TypeParamDecl *InternalTypeRef::decl_as<Metadata::TypeParamDecl>() const
{
    return decl_as_typeParam();
}

struct InternalTypeRefBuilder {
    typedef InternalTypeRef Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_decl_type(Metadata::RefType decl_type)
    {
        fbb_.AddElement<uint8_t>(InternalTypeRef::VT_DECL_TYPE, static_cast<uint8_t>(decl_type), 0);
    }
    void add_decl(::flatbuffers::Offset<void> decl)
    {
        fbb_.AddOffset(InternalTypeRef::VT_DECL, decl);
    }
    explicit InternalTypeRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<InternalTypeRef> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<InternalTypeRef>(end);
        fbb_.Required(o, InternalTypeRef::VT_DECL);
        return o;
    }
};

inline ::flatbuffers::Offset<InternalTypeRef> CreateInternalTypeRef(
    ::flatbuffers::FlatBufferBuilder &_fbb, Metadata::RefType decl_type = Metadata::REF_TYPE_NONE,
    ::flatbuffers::Offset<void> decl = 0)
{
    InternalTypeRefBuilder builder(_fbb);
    builder.add_decl(decl);
    builder.add_decl_type(decl_type);
    return builder.Finish();
}

struct ExternalTypeRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ExternalTypeRefBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FQNAME = 4 };
    const ::flatbuffers::String *fqname() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_FQNAME);
    }
    ::flatbuffers::String *mutable_fqname()
    {
        return GetPointer<::flatbuffers::String *>(VT_FQNAME);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_FQNAME) &&
               verifier.VerifyString(fqname()) && verifier.EndTable();
    }
};

struct ExternalTypeRefBuilder {
    typedef ExternalTypeRef Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_fqname(::flatbuffers::Offset<::flatbuffers::String> fqname)
    {
        fbb_.AddOffset(ExternalTypeRef::VT_FQNAME, fqname);
    }
    explicit ExternalTypeRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ExternalTypeRef> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ExternalTypeRef>(end);
        fbb_.Required(o, ExternalTypeRef::VT_FQNAME);
        return o;
    }
};

inline ::flatbuffers::Offset<ExternalTypeRef> CreateExternalTypeRef(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> fqname = 0)
{
    ExternalTypeRefBuilder builder(_fbb);
    builder.add_fqname(fqname);
    return builder.Finish();
}

inline ::flatbuffers::Offset<ExternalTypeRef> CreateExternalTypeRefDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                          const char *fqname = nullptr)
{
    auto fqname__ = fqname ? _fbb.CreateString(fqname) : 0;
    return Metadata::CreateExternalTypeRef(_fbb, fqname__);
}

struct FunctionTypeParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FunctionTypeParamBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_TYPE_TYPE = 6, VT_TYPE = 8 };
    const ::flatbuffers::String *name() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    ::flatbuffers::String *mutable_name()
    {
        return GetPointer<::flatbuffers::String *>(VT_NAME);
    }
    Metadata::Type type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
    }
    const void *type() const
    {
        return GetPointer<const void *>(VT_TYPE);
    }
    template <typename T>
    const T *type_as() const;
    const Metadata::BuiltinType *type_as_Builtin() const
    {
        return type_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(type()) : nullptr;
    }
    const Metadata::InternalTypeRef *type_as_RefInternal() const
    {
        return type_type() == Metadata::TYPE_REF_INTERNAL ? static_cast<const Metadata::InternalTypeRef *>(type())
                                                          : nullptr;
    }
    const Metadata::ExternalTypeRef *type_as_RefExternal() const
    {
        return type_type() == Metadata::TYPE_REF_EXTERNAL ? static_cast<const Metadata::ExternalTypeRef *>(type())
                                                          : nullptr;
    }
    const Metadata::FunctionType *type_as_Function() const
    {
        return type_type() == Metadata::TYPE_FUNCTION ? static_cast<const Metadata::FunctionType *>(type()) : nullptr;
    }
    const Metadata::TupleType *type_as_Tuple() const
    {
        return type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(type()) : nullptr;
    }
    const Metadata::UnionType *type_as_Union() const
    {
        return type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(type()) : nullptr;
    }
    const Metadata::StringLiteralType *type_as_StringLiteral() const
    {
        return type_type() == Metadata::TYPE_STRING_LITERAL ? static_cast<const Metadata::StringLiteralType *>(type())
                                                            : nullptr;
    }
    void *mutable_type()
    {
        return GetPointer<void *>(VT_TYPE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyField<uint8_t>(verifier, VT_TYPE_TYPE, 1) && VerifyOffsetRequired(verifier, VT_TYPE) &&
               VerifyType(verifier, type(), type_type()) && verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *FunctionTypeParam::type_as<Metadata::BuiltinType>() const
{
    return type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *FunctionTypeParam::type_as<Metadata::InternalTypeRef>() const
{
    return type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *FunctionTypeParam::type_as<Metadata::ExternalTypeRef>() const
{
    return type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *FunctionTypeParam::type_as<Metadata::FunctionType>() const
{
    return type_as_Function();
}

template <>
inline const Metadata::TupleType *FunctionTypeParam::type_as<Metadata::TupleType>() const
{
    return type_as_Tuple();
}

template <>
inline const Metadata::UnionType *FunctionTypeParam::type_as<Metadata::UnionType>() const
{
    return type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *FunctionTypeParam::type_as<Metadata::StringLiteralType>() const
{
    return type_as_StringLiteral();
}

struct FunctionTypeParamBuilder {
    typedef FunctionTypeParam Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
        fbb_.AddOffset(FunctionTypeParam::VT_NAME, name);
    }
    void add_type_type(Metadata::Type type_type)
    {
        fbb_.AddElement<uint8_t>(FunctionTypeParam::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
    }
    void add_type(::flatbuffers::Offset<void> type)
    {
        fbb_.AddOffset(FunctionTypeParam::VT_TYPE, type);
    }
    explicit FunctionTypeParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FunctionTypeParam> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FunctionTypeParam>(end);
        fbb_.Required(o, FunctionTypeParam::VT_TYPE);
        return o;
    }
};

inline ::flatbuffers::Offset<FunctionTypeParam> CreateFunctionTypeParam(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    Metadata::Type type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> type = 0)
{
    FunctionTypeParamBuilder builder(_fbb);
    builder.add_type(type);
    builder.add_name(name);
    builder.add_type_type(type_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<FunctionTypeParam> CreateFunctionTypeParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr, Metadata::Type type_type = Metadata::TYPE_NONE,
    ::flatbuffers::Offset<void> type = 0)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return Metadata::CreateFunctionTypeParam(_fbb, name__, type_type, type);
}

struct FunctionType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FunctionTypeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PARAMS = 4,
        VT_RETURN_TYPE_TYPE = 6,
        VT_RETURN_TYPE = 8
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>> *params() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>> *>(VT_PARAMS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>> *mutable_params()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>> *>(VT_PARAMS);
    }
    Metadata::Type return_type_type() const
    {
        return static_cast<Metadata::Type>(GetField<uint8_t>(VT_RETURN_TYPE_TYPE, 0));
    }
    const void *return_type() const
    {
        return GetPointer<const void *>(VT_RETURN_TYPE);
    }
    template <typename T>
    const T *return_type_as() const;
    const Metadata::BuiltinType *return_type_as_Builtin() const
    {
        return return_type_type() == Metadata::TYPE_BUILTIN ? static_cast<const Metadata::BuiltinType *>(return_type())
                                                            : nullptr;
    }
    const Metadata::InternalTypeRef *return_type_as_RefInternal() const
    {
        return return_type_type() == Metadata::TYPE_REF_INTERNAL
                   ? static_cast<const Metadata::InternalTypeRef *>(return_type())
                   : nullptr;
    }
    const Metadata::ExternalTypeRef *return_type_as_RefExternal() const
    {
        return return_type_type() == Metadata::TYPE_REF_EXTERNAL
                   ? static_cast<const Metadata::ExternalTypeRef *>(return_type())
                   : nullptr;
    }
    const Metadata::FunctionType *return_type_as_Function() const
    {
        return return_type_type() == Metadata::TYPE_FUNCTION
                   ? static_cast<const Metadata::FunctionType *>(return_type())
                   : nullptr;
    }
    const Metadata::TupleType *return_type_as_Tuple() const
    {
        return return_type_type() == Metadata::TYPE_FUPLE ? static_cast<const Metadata::TupleType *>(return_type())
                                                          : nullptr;
    }
    const Metadata::UnionType *return_type_as_Union() const
    {
        return return_type_type() == Metadata::TYPE_UNION ? static_cast<const Metadata::UnionType *>(return_type())
                                                          : nullptr;
    }
    const Metadata::StringLiteralType *return_type_as_StringLiteral() const
    {
        return return_type_type() == Metadata::TYPE_STRING_LITERAL
                   ? static_cast<const Metadata::StringLiteralType *>(return_type())
                   : nullptr;
    }
    void *mutable_return_type()
    {
        return GetPointer<void *>(VT_RETURN_TYPE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PARAMS) && verifier.VerifyVector(params()) &&
               verifier.VerifyVectorOfTables(params()) && VerifyField<uint8_t>(verifier, VT_RETURN_TYPE_TYPE, 1) &&
               VerifyOffsetRequired(verifier, VT_RETURN_TYPE) &&
               VerifyType(verifier, return_type(), return_type_type()) && verifier.EndTable();
    }
};

template <>
inline const Metadata::BuiltinType *FunctionType::return_type_as<Metadata::BuiltinType>() const
{
    return return_type_as_Builtin();
}

template <>
inline const Metadata::InternalTypeRef *FunctionType::return_type_as<Metadata::InternalTypeRef>() const
{
    return return_type_as_RefInternal();
}

template <>
inline const Metadata::ExternalTypeRef *FunctionType::return_type_as<Metadata::ExternalTypeRef>() const
{
    return return_type_as_RefExternal();
}

template <>
inline const Metadata::FunctionType *FunctionType::return_type_as<Metadata::FunctionType>() const
{
    return return_type_as_Function();
}

template <>
inline const Metadata::TupleType *FunctionType::return_type_as<Metadata::TupleType>() const
{
    return return_type_as_Tuple();
}

template <>
inline const Metadata::UnionType *FunctionType::return_type_as<Metadata::UnionType>() const
{
    return return_type_as_Union();
}

template <>
inline const Metadata::StringLiteralType *FunctionType::return_type_as<Metadata::StringLiteralType>() const
{
    return return_type_as_StringLiteral();
}

struct FunctionTypeBuilder {
    typedef FunctionType Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_params(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>>> params)
    {
        fbb_.AddOffset(FunctionType::VT_PARAMS, params);
    }
    void add_return_type_type(Metadata::Type return_type_type)
    {
        fbb_.AddElement<uint8_t>(FunctionType::VT_RETURN_TYPE_TYPE, static_cast<uint8_t>(return_type_type), 0);
    }
    void add_return_type(::flatbuffers::Offset<void> return_type)
    {
        fbb_.AddOffset(FunctionType::VT_RETURN_TYPE, return_type);
    }
    explicit FunctionTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FunctionType> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FunctionType>(end);
        fbb_.Required(o, FunctionType::VT_RETURN_TYPE);
        return o;
    }
};

inline ::flatbuffers::Offset<FunctionType> CreateFunctionType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>>> params = 0,
    Metadata::Type return_type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> return_type = 0)
{
    FunctionTypeBuilder builder(_fbb);
    builder.add_return_type(return_type);
    builder.add_params(params);
    builder.add_return_type_type(return_type_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<FunctionType> CreateFunctionTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Metadata::FunctionTypeParam>> *params = nullptr,
    Metadata::Type return_type_type = Metadata::TYPE_NONE, ::flatbuffers::Offset<void> return_type = 0)
{
    auto params__ = params ? _fbb.CreateVector<::flatbuffers::Offset<Metadata::FunctionTypeParam>>(*params) : 0;
    return Metadata::CreateFunctionType(_fbb, params__, return_type_type, return_type);
}

struct TupleType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef TupleTypeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ELEMENTS_TYPE = 4, VT_ELEMENTS = 6 };
    const ::flatbuffers::Vector<uint8_t> *elements_type() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ELEMENTS_TYPE);
    }
    ::flatbuffers::Vector<uint8_t> *mutable_elements_type()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_ELEMENTS_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *elements() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_ELEMENTS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<void>> *mutable_elements()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_ELEMENTS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ELEMENTS_TYPE) &&
               verifier.VerifyVector(elements_type()) && VerifyOffset(verifier, VT_ELEMENTS) &&
               verifier.VerifyVector(elements()) && VerifyTypeVector(verifier, elements(), elements_type()) &&
               verifier.EndTable();
    }
};

struct TupleTypeBuilder {
    typedef TupleType Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_elements_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> elements_type)
    {
        fbb_.AddOffset(TupleType::VT_ELEMENTS_TYPE, elements_type);
    }
    void add_elements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> elements)
    {
        fbb_.AddOffset(TupleType::VT_ELEMENTS, elements);
    }
    explicit TupleTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TupleType> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TupleType>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TupleType> CreateTupleType(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> elements_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> elements = 0)
{
    TupleTypeBuilder builder(_fbb);
    builder.add_elements(elements);
    builder.add_elements_type(elements_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<TupleType> CreateTupleTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<uint8_t> *elements_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *elements = nullptr)
{
    auto elements_type__ = elements_type ? _fbb.CreateVector<uint8_t>(*elements_type) : 0;
    auto elements__ = elements ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*elements) : 0;
    return Metadata::CreateTupleType(_fbb, elements_type__, elements__);
}

struct UnionType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef UnionTypeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_COMPONENTS_TYPE = 4, VT_COMPONENTS = 6 };
    const ::flatbuffers::Vector<uint8_t> *components_type() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_COMPONENTS_TYPE);
    }
    ::flatbuffers::Vector<uint8_t> *mutable_components_type()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_COMPONENTS_TYPE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *components() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_COMPONENTS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<void>> *mutable_components()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_COMPONENTS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_COMPONENTS_TYPE) &&
               verifier.VerifyVector(components_type()) && VerifyOffsetRequired(verifier, VT_COMPONENTS) &&
               verifier.VerifyVector(components()) && VerifyTypeVector(verifier, components(), components_type()) &&
               verifier.EndTable();
    }
};

struct UnionTypeBuilder {
    typedef UnionType Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_components_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> components_type)
    {
        fbb_.AddOffset(UnionType::VT_COMPONENTS_TYPE, components_type);
    }
    void add_components(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> components)
    {
        fbb_.AddOffset(UnionType::VT_COMPONENTS, components);
    }
    explicit UnionTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<UnionType> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<UnionType>(end);
        fbb_.Required(o, UnionType::VT_COMPONENTS_TYPE);
        fbb_.Required(o, UnionType::VT_COMPONENTS);
        return o;
    }
};

inline ::flatbuffers::Offset<UnionType> CreateUnionType(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> components_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> components = 0)
{
    UnionTypeBuilder builder(_fbb);
    builder.add_components(components);
    builder.add_components_type(components_type);
    return builder.Finish();
}

inline ::flatbuffers::Offset<UnionType> CreateUnionTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<uint8_t> *components_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *components = nullptr)
{
    auto components_type__ = components_type ? _fbb.CreateVector<uint8_t>(*components_type) : 0;
    auto components__ = components ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*components) : 0;
    return Metadata::CreateUnionType(_fbb, components_type__, components__);
}

struct StringLiteralType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef StringLiteralTypeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUE = 4 };
    const ::flatbuffers::String *value() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
    }
    ::flatbuffers::String *mutable_value()
    {
        return GetPointer<::flatbuffers::String *>(VT_VALUE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VALUE) &&
               verifier.VerifyString(value()) && verifier.EndTable();
    }
};

struct StringLiteralTypeBuilder {
    typedef StringLiteralType Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_value(::flatbuffers::Offset<::flatbuffers::String> value)
    {
        fbb_.AddOffset(StringLiteralType::VT_VALUE, value);
    }
    explicit StringLiteralTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<StringLiteralType> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<StringLiteralType>(end);
        fbb_.Required(o, StringLiteralType::VT_VALUE);
        return o;
    }
};

inline ::flatbuffers::Offset<StringLiteralType> CreateStringLiteralType(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> value = 0)
{
    StringLiteralTypeBuilder builder(_fbb);
    builder.add_value(value);
    return builder.Finish();
}

inline ::flatbuffers::Offset<StringLiteralType> CreateStringLiteralTypeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                              const char *value = nullptr)
{
    auto value__ = value ? _fbb.CreateString(value) : 0;
    return Metadata::CreateStringLiteralType(_fbb, value__);
}

// CC-OFFNXT(G.FUD.06) flatbuffers auto-generated code
inline bool VerifyRefType(::flatbuffers::Verifier &verifier, const void *obj, RefType type)
{
    switch (type) {
        case REF_TYPE_NONE: {
            return true;
        }
        case REF_TYPE_CLASS: {
            auto ptr = reinterpret_cast<const Metadata::ClassDecl *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case REF_TYPE_INTERFACE: {
            auto ptr = reinterpret_cast<const Metadata::InterfaceDecl *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case REF_TYPE_ENUM: {
            auto ptr = reinterpret_cast<const Metadata::EnumDecl *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case REF_TYPE_ANNOTATION: {
            auto ptr = reinterpret_cast<const Metadata::AnnotationDecl *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case REF_TYPE_TYPE: {
            auto ptr = reinterpret_cast<const Metadata::TypeDecl *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case REF_TYPE_TYPE_PARAM: {
            auto ptr = reinterpret_cast<const Metadata::TypeParamDecl *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifyRefTypeVector(::flatbuffers::Verifier &verifier,
                                const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                                const ::flatbuffers::Vector<uint8_t> *types)
{
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifyRefType(verifier, values->Get(i), types->GetEnum<RefType>(i))) {
            return false;
        }
    }
    return true;
}

// CC-OFFNXT(G.FUD.06) flatbuffers auto-generated code
inline bool VerifyType(::flatbuffers::Verifier &verifier, const void *obj, Type type)
{
    switch (type) {
        case TYPE_NONE: {
            return true;
        }
        case TYPE_BUILTIN: {
            auto ptr = reinterpret_cast<const Metadata::BuiltinType *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case TYPE_REF_INTERNAL: {
            auto ptr = reinterpret_cast<const Metadata::InternalTypeRef *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case TYPE_REF_EXTERNAL: {
            auto ptr = reinterpret_cast<const Metadata::ExternalTypeRef *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case TYPE_FUNCTION: {
            auto ptr = reinterpret_cast<const Metadata::FunctionType *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case TYPE_FUPLE: {
            auto ptr = reinterpret_cast<const Metadata::TupleType *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case TYPE_UNION: {
            auto ptr = reinterpret_cast<const Metadata::UnionType *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case TYPE_STRING_LITERAL: {
            auto ptr = reinterpret_cast<const Metadata::StringLiteralType *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifyTypeVector(::flatbuffers::Verifier &verifier,
                             const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
                             const ::flatbuffers::Vector<uint8_t> *types)
{
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifyType(verifier, values->Get(i), types->GetEnum<Type>(i))) {
            return false;
        }
    }
    return true;
}

inline const Metadata::Root *GetRoot(const void *buf)
{
    return ::flatbuffers::GetRoot<Metadata::Root>(buf);
}

inline const Metadata::Root *GetSizePrefixedRoot(const void *buf)
{
    return ::flatbuffers::GetSizePrefixedRoot<Metadata::Root>(buf);
}

inline Root *GetMutableRoot(void *buf)
{
    return ::flatbuffers::GetMutableRoot<Root>(buf);
}

inline Metadata::Root *GetMutableSizePrefixedRoot(void *buf)
{
    return ::flatbuffers::GetMutableSizePrefixedRoot<Metadata::Root>(buf);
}

inline bool VerifyRootBuffer(::flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<Metadata::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(::flatbuffers::Verifier &verifier)
{
    return verifier.VerifySizePrefixedBuffer<Metadata::Root>(nullptr);
}

inline void FinishRootBuffer(::flatbuffers::FlatBufferBuilder &fbb, ::flatbuffers::Offset<Metadata::Root> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                         ::flatbuffers::Offset<Metadata::Root> root)
{
    fbb.FinishSizePrefixed(root);
}

}  // namespace Metadata

#endif  // FLATBUFFERS_GENERATED_METADATA_METADATA_H