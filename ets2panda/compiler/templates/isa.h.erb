% def get_node_kind(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}"
% end
%
% def get_format_name(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_FORMATS"
% end
% def get_reg_limit_name(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_REG_LIMIT"
% end
% def get_operand_reg_kind_name(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_OPERAND_REG_KIND"
% end
/**
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

#ifndef ES2PANDA_COMPILER_GEN_IR_ISA_H
#define ES2PANDA_COMPILER_GEN_IR_ISA_H

#include "ir/irnode.h"
#include "generated/formats.h"
#include "generated/signatures.h"

#include "assembly-function.h"
#include "assembly-ins.h"
#include "assembly-type.h"

namespace ark::es2panda::compiler {
class Label : public IRNode {
public:
    explicit Label(const ir::AstNode* node, std::string id) : IRNode(node), id_(std::move(id)) {}

    static constexpr std::string_view PREFIX = "LABEL_";

    Formats GetFormats() const override
    {
        return Span<const Format>(nullptr, nullptr);
    }

    const std::string &Id() const
    {
        return id_;
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
        return 0;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    size_t OutRegisters([[maybe_unused]] std::array<OutVReg, MAX_REG_OPERAND>* regs) const override
    {
        return 0;
    }

    OperandType GetOperandRegType([[maybe_unused]] size_t idx) const override
    {
        return OperandType::NONE;
    }

    uint32_t GetRegLimit() const noexcept override
    {
        return 0U;
    }

    OperandKind GetOperandRegKind([[maybe_unused]] size_t idx) const override
    {
        return LABEL_OPERAND_REG_KIND[idx];
    }

    void Transform(pandasm::Ins *ins, [[maybe_unused]] ProgramElement *programElement,
                   [[maybe_unused]] uint32_t totalRegs) const override
    {
        ins->opcode = pandasm::Opcode::INVALID;
        ins->SetLabel(id_);
    }

private:
    std::string id_;
};

static bool IsAccessor(const std::string &calleeInternalName)
{
    auto methodEndPos = calleeInternalName.find(Signatures::MANGLE_BEGIN);
    if (methodEndPos == std::string::npos) {
        return false;
    }
    auto pos = calleeInternalName.rfind(Signatures::METHOD_SEPARATOR, methodEndPos);
    if (pos == std::string::npos) {
        return false;
    }
    auto methodBeginPos = pos + 1;
    // case 1. getter: "xxx.<get>PropName:PropType;"  name start with '<get>'
    auto checkGetterPos = calleeInternalName.find(Signatures::GETTER_METHOD_BEGIN, methodBeginPos);
    if (checkGetterPos == methodBeginPos) {
        return true;
    }
    // case 2. setter: "xxx.<set>PropName:PropType;void;"  name start with '<set>'
    auto checkSetterPos = calleeInternalName.find(Signatures::SETTER_METHOD_BEGIN, methodBeginPos);
    if (checkSetterPos == methodBeginPos) {
        return true;
    }

    // case 3. indexed getter: "xxx.$_get:ValueType;"  name is '$_get'
    // case 4. indexed setter: "xxx.$_set:IndexType;ValueType;void;"  name is '$_set'
    ES2PANDA_ASSERT(Signatures::GET_INDEX_METHOD.length() == Signatures::SET_INDEX_METHOD.length());
    const auto indexMethodLen = Signatures::GET_INDEX_METHOD.length();
    if (methodEndPos != methodBeginPos + indexMethodLen) {
        return false;
    }
    auto methodName = calleeInternalName.substr(methodBeginPos, indexMethodLen);
    return methodName == Signatures::GET_INDEX_METHOD || methodName == Signatures::SET_INDEX_METHOD;
}

static OperandType GetOperandRegTypeForNormalCall(const std::string &calleeInternalName, size_t argIdx)
{
    const std::string &str = calleeInternalName;
    auto pos = str.find(Signatures::MANGLE_BEGIN);
    ES2PANDA_ASSERT(pos != std::string::npos);
    for (size_t i = 0; i < argIdx; ++i) {
        pos = str.find(Signatures::MANGLE_SEPARATOR, pos + 1);
        ES2PANDA_ASSERT(pos != std::string::npos);
    }
    auto end = str.find(Signatures::MANGLE_SEPARATOR, pos + 1);
    ES2PANDA_ASSERT(end != std::string::npos);
    ES2PANDA_ASSERT(end > pos + 1);
    auto argTypeName = str.substr(pos + 1, end - pos - 1);
    auto argType = ark::pandasm::Type::FromName(argTypeName);
    if (argType.IsPrim32()) {
        return OperandType::B32;
    }
    if (argType.IsPrim64()) {
        return OperandType::B64;
    }
    return OperandType::REF;
}

static OperandType GetOperandRegTypeForAccessor(const std::string &calleeInternalName, size_t argIdx,
                                                bool hadCalculatedThis)
{
    // the first arg may be the omitted 'this', but it may calculated in `GetOperandRegType`
    // do not calculate twice.
    ES2PANDA_ASSERT(IsAccessor(calleeInternalName));
    if (argIdx == 0 && !hadCalculatedThis) {
        return OperandType::REF;
    }

    ES2PANDA_ASSERT(hadCalculatedThis || argIdx > 0);
    argIdx = hadCalculatedThis ? argIdx : argIdx - 1;
    return GetOperandRegTypeForNormalCall(calleeInternalName, argIdx);
}

static OperandType GetOperandRegTypeForCall(const std::string &calleeInternalName, size_t argIdx,
                                            bool hadCalculatedThis = false)
{
    if (IsAccessor(calleeInternalName)) {  // in such cases method signatures lacks the first arg 'this'
        return GetOperandRegTypeForAccessor(calleeInternalName, argIdx, hadCalculatedThis);
    }
    return GetOperandRegTypeForNormalCall(calleeInternalName, argIdx);
}

// NOLINTBEGIN(readability-identifier-naming)
% def insn2node(insn)
%   mnemonic = insn.mnemonic.split('.')
%   return mnemonic.map{|el| el == '64' ? 'Wide' : el.capitalize}.join()
% end
%
% def get_ctor_args(insn)
%     ops = Array.new
%     ctor_args = Array.new
%     op_map = Hash.new { |h, k| h[k] = [] }
%
%     insn.operands.map do |operand|
%       name = operand.name
%       param_name = name
%       if operand.reg?
%         param_name = "#{name}#{op_map['reg'].size}"
%         op_map['reg_type'].push(["#{param_name}_", operand.type])
%         op_map['reg'].push("#{param_name}_")
%         op_map['dreg'].push(["#{param_name}_", operand.type]) if operand.dst?
%         op_map['dreg'].push([nil, nil]) unless operand.dst?
%         type = 'VReg'
%       elsif operand.imm?
%         if insn.jump?
%           op_map['lbl'].push("#{name}_")
%           type = 'Label*'
%         else
%           param_name = "#{name}#{op_map['imm'].size}"
%           op_map['imm'].push("#{param_name}_")
%           type = operand.type == 'f64' ? 'double' : operand.type == 'f32' ? 'float' : 'int64_t'
%         end
%       elsif operand.id?
%         param_name = 'string_id'
%         op_map['str'].push("#{param_name}_")
%         type = 'util::StringView'
%       end
%       ops.push(param_name)
%       ctor_args.push("#{type} #{param_name}")
%     end
%     return ops,ctor_args,op_map
% end
%
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
% insn = group.first
% node_kind = get_node_kind(mnemonic)
% class_name = insn2node(insn)
% base_class = "IRNode"
% ops_list,ctor_arg_list,op_map = get_ctor_args(insn)
% ctor_args = "const ir::AstNode* node" + (ctor_arg_list.length == 0 ? "" : ", ") + ctor_arg_list.map {|arg| "#{arg}"}.join(", ")
% members = ctor_arg_list.map {|arg| "#{arg}_;"}.join("\n    ")
% registers = op_map['reg'].map {|reg| "&#{reg}"}.join(", ")
% ops = (ops_list.length == 0 ? "" : ", ") + ops_list.map { |op| "#{op}_(#{op})"}.join(", ")
class <%= class_name %> : public <%= base_class %>
{
public:
    explicit <%= class_name %>(<%= ctor_args %>) : <%= base_class %>(node)<%= ops %>
    {
% insn.operands.each do |operand|
%   if operand.id? && operand.name != :string_id
        ES2PANDA_ASSERT(!string_id.Empty());
%   end
% end
    }

    Formats GetFormats() const override
    {
        return Span<const Format>(<%= get_format_name(insn.mnemonic) %>);
    }

    size_t Registers([[maybe_unused]] std::array<VReg*, MAX_REG_OPERAND>* regs) override
    {
% reg_cnt = 0
% for reg in op_map['reg']
        (*regs)[<%= reg_cnt %>] = &<%= reg %>;
%   reg_cnt+=1;
% end
        return <%= reg_cnt %>;
    }

    size_t Registers([[maybe_unused]] std::array<const VReg*, MAX_REG_OPERAND>* regs) const override
    {
% reg_cnt = 0
% for reg in op_map['reg']
        (*regs)[<%= reg_cnt %>] = &<%= reg %>;
%   reg_cnt+=1;
% end
        return <%= reg_cnt %>;
    }

    size_t OutRegisters([[maybe_unused]] std::array<OutVReg, MAX_REG_OPERAND>* regs) const override
    {
% reg_cnt = 0
%
% def type_to_enum(type)
%   return 'REF' if type == 'ref'
%   return 'ANY' if type == 'any'
%   return 'B64' if type == 'f64' || type == 'i64' || type == 'b64'
%   return 'B32'
% end
% for reg, type in op_map['dreg']
%   if reg
        (*regs)[<%= reg_cnt %>] = {&<%= reg %>, OperandType::<%= type_to_enum(type) %>};
%   else
        (*regs)[<%= reg_cnt %>] = {nullptr, OperandType::NONE};
%   end
%   reg_cnt+=1;
% end
        return <%= reg_cnt %>;
    }

% def type_to_mov_kind(type)
%   return 'REF' if type == 'ref'
%   return 'REF' if type.include? '[]'
%   return 'B64' if type == 'i64' || type == 'u64' || type == 'f64' || type == 'b64'
%   return 'ANY' if type == 'any'
%   return 'B32' if type == 'u1' || type == 'u2' || type == 'u4' ||    \
%                   type == 'i8' || type == 'u8' || type == 'b8' ||    \
%                   type == 'i16' || type == 'u16' || type == 'b16' || \
%                   type == 'i32' || type == 'u32' || type == 'f32' || type == 'b32'
%   return 'NONE' if type == 'top'
%   raise "invalid reg type #{type}"
% end
%
    OperandType GetOperandRegType([[maybe_unused]] size_t idx) const override {
% if insn.mnemonic.start_with?('call.virt')
        if (idx == 0) {
            return OperandType::REF;
        }
        return GetOperandRegTypeForCall(string_id_.Mutf8(), idx - 1, true);

% elsif insn.mnemonic.start_with?('call.acc')
        {
            size_t argIdx = (idx >= static_cast<size_t>(imm0_)) ? idx + 1 : idx;
            return GetOperandRegTypeForCall(string_id_.Mutf8(), argIdx);
        }

% elsif insn.properties.any? { |prop| prop.include?('method_id') }  # 从 method_id 解析
        return GetOperandRegTypeForCall(string_id_.Mutf8(), idx);
% elsif insn.mnemonic.start_with?('any.') && insn.mnemonic.end_with?('.range') # any.x.range always have operand type REG
        ES2PANDA_ASSERT(imm0_ >= 0);
        ES2PANDA_ASSERT(idx < static_cast<size_t>(imm0_));
        return OperandType::REF;
% else # get operand type from reg type defined in isa.yaml
        switch (idx) {
% i = 0
% for reg, type in op_map['reg_type']
            case <%= i %>: {
                return OperandType::<%= type_to_mov_kind(type) %>;
            }
% i+=1
% end
            default: {
                ES2PANDA_UNREACHABLE();
                break;
            }
        }
        return OperandType::NONE;
% end
    }

    uint32_t GetRegLimit() const noexcept override
    {
        return <%= get_reg_limit_name(insn.mnemonic) %>;
    }

    OperandKind GetOperandRegKind(size_t idx) const override
    {
        return <%= get_operand_reg_kind_name(insn.mnemonic) %>[idx];
    }

    void Transform(pandasm::Ins *ins, [[maybe_unused]] ProgramElement *programElement,
                   [[maybe_unused]] uint32_t totalRegs) const override {
      ins->opcode = pandasm::Opcode::<%= node_kind %>;
      if (IsDevirtual()) {
        ins->SetIsDevirtual();
      }
% for reg in op_map['reg']
      ins->EmplaceReg(MapRegister(<%= reg %>.GetIndex(), totalRegs));
% end
% for imm in op_map['imm']
      ins->EmplaceImm(<%= imm %>);
% end
% if insn.properties.include? 'literalarray_id' and insn.properties.none? 'skip_literal_id_patch'
      programElement->LiteralBufferIns().push_back(ins);
%end
% for str in op_map['str']
      std::string <%= str %>mutf8 = <%= str %>.Mutf8();
      ins->EmplaceID(<%= str %>mutf8);
      programElement->Strings().insert(std::move(<%= str %>mutf8));
% end
% for lbl in op_map['lbl']
      ins->EmplaceID(<%= lbl %>->Id());
% end
    }

% if ops_list.length != 0
private:
    <%= members %>
% end
};

% end
// NOLINTEND(readability-identifier-naming)
}  // namespace ark::es2panda::compiler

#endif
